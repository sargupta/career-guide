from fastapi import APIRouter, Depends, HTTPException
from pydantic import BaseModel
from typing import List, Optional
from api.auth import get_current_user
from db.supabase_client import get_supabase_anon
from agents.lead_mentor import get_orchestratorResponse

router = APIRouter()

class QuizGenerateRequest(BaseModel):
    topic: str
    subject: str
    grade_level: str
    count: int = 5

class LessonPlanRequest(BaseModel):
    topic: str
    subject: str
    grade_level: str

@router.post("/quiz/generate")
async def generate_quiz(req: QuizGenerateRequest, user: dict = Depends(get_current_user)):
    """Generates a pedagogical quiz using the ClassroomExpert agent."""
    user_id = user["user_id"]
    token = user["token"]
    
    prompt = f"Generate a {req.count}-question quiz on '{req.topic}' for Grade {req.grade_level} {req.subject}. Align with Bloom's Taxonomy."
    system_hint = "CRITICAL: Return ONLY a raw JSON array of question objects. Example: [{'question': '...', 'options': [...], 'answer': '...', 'level': '...', 'explanation': '...'}]"
    
    # Use LeadMentor to orchestrate with ClassroomExpert
    profile = {"user_role": "teacher", "grade_level": req.grade_level, "subject": req.subject}
    reply = await get_orchestratorResponse(profile, prompt, system_hint=system_hint)
    
    try:
        clean_reply = reply.replace("```json", "").replace("```", "").strip()
        quiz_json = __import__("json").loads(clean_reply)
        
        # Save to DB
        db = get_supabase_anon(token)
        res = db.table("teacher_assets").insert({
            "teacher_id": user_id,
            "asset_type": "quiz",
            "subject": req.subject,
            "grade_level": req.grade_level,
            "title": f"{req.topic} Quiz",
            "content_json": quiz_json
        }).execute()
        
        return {"quiz": quiz_json, "asset_id": res.data[0]["id"] if res.data else None}
    except Exception as e:
        return {"error": "Quiz generation failed", "raw_reply": reply}

@router.post("/lesson/generate")
async def generate_lesson_plan(req: LessonPlanRequest, user: dict = Depends(get_current_user)):
    """Generates a structured lesson plan using the ClassroomExpert agent."""
    user_id = user["user_id"]
    token = user["token"]
    
    prompt = f"Create a structured lesson plan using the 5E Model for '{req.topic}' (Grade {req.grade_level} {req.subject})."
    system_hint = "CRITICAL: Return ONLY a raw JSON object. Example: {'title': '...', 'objectives': [...], 'duration': '...', 'sections': [...]}"
    
    profile = {"user_role": "teacher", "grade_level": req.grade_level, "subject": req.subject}
    reply = await get_orchestratorResponse(profile, prompt, system_hint=system_hint)
    
    try:
        clean_reply = reply.replace("```json", "").replace("```", "").strip()
        lesson_json = __import__("json").loads(clean_reply)
        
        # Save to DB
        db = get_supabase_anon(token)
        res = db.table("teacher_assets").insert({
            "teacher_id": user_id,
            "asset_type": "lesson_plan",
            "subject": req.subject,
            "grade_level": req.grade_level,
            "title": f"{req.topic} Lesson Plan",
            "content_json": lesson_json
        }).execute()
        
        return {"lesson_plan": lesson_json, "asset_id": res.data[0]["id"] if res.data else None}
    except Exception as e:
        return {"error": "Lesson plan generation failed", "raw_reply": reply}

@router.get("/assets")
async def get_teacher_assets(user: dict = Depends(get_current_user)):
    """Retrieves all assets generated by the teacher."""
    db = get_supabase_anon(user["token"])
    res = db.table("teacher_assets").select("*").eq("teacher_id", user["user_id"]).order("created_at", desc=True).execute()
    return {"assets": res.data or []}

@router.patch("/assets/{asset_id}")
async def update_asset_visibility(asset_id: str, is_public: bool, user: dict = Depends(get_current_user)):
    """Toggles public visibility of a teacher asset."""
    db = get_supabase_anon(user["token"])
    res = db.table("teacher_assets").update({"is_public": is_public}).eq("id", asset_id).eq("teacher_id", user["user_id"]).execute()
    return res.data[0]

@router.get("/community")
async def get_community_assets(subject: Optional[str] = None, grade: Optional[str] = None):
    """Fetches public assets from the community."""
    # Note: Using anon client directly as these are public
    from db.supabase_client import get_supabase_client
    db = get_supabase_client()
    query = db.table("teacher_assets").select("*, profiles!teacher_id(full_name)").eq("is_public", True)
    if subject:
        query = query.eq("subject", subject)
    if grade:
        query = query.eq("grade_level", grade)
    res = query.order("created_at", desc=True).limit(50).execute()
    return {"assets": res.data or []}

@router.post("/assets/{asset_id}/remix")
async def remix_asset(asset_id: str, user: dict = Depends(get_current_user)):
    """Creates a user copy of a public asset and tracks the remix."""
    db = get_supabase_anon(user["token"])
    
    # 1. Fetch original
    original = db.table("teacher_assets").select("*").eq("id", asset_id).eq("is_public", True).single().execute()
    if not original.data:
        raise HTTPException(status_code=404, detail="Public asset not found")
    
    # 2. Create copy
    asset_data = original.data
    new_asset = {
        "teacher_id": user["user_id"],
        "asset_type": asset_data["asset_type"],
        "subject": asset_data["subject"],
        "grade_level": asset_data["grade_level"],
        "title": f"{asset_data['title']} (Remix)",
        "content_json": asset_data["content_json"],
        "remixed_from": asset_id
    }
    res = db.table("teacher_assets").insert(new_asset).execute()
    
    # 3. Increment original's clone count
    db.table("teacher_assets").update({
        "clones_count": asset_data.get("clones_count", 0) + 1
    }).eq("id", asset_id).execute()
    
    return res.data[0]

@router.get("/impact")
async def get_teacher_impact(user: dict = Depends(get_current_user)):
    """Calculates teacher impact metrics."""
    db = get_supabase_anon(user["token"])
    user_id = user["user_id"]
    
    # 1. Fetch all assets
    res = db.table("teacher_assets").select("*").eq("teacher_id", user_id).execute()
    assets = res.data or []
    
    total_generated = len(assets)
    # Estimate: 1 hr per quiz, 2 hrs per lesson plan
    hours_saved = sum(2 if a["asset_type"] == "lesson_plan" else 1 for a in assets)
    total_remixes = sum(a.get("clones_count", 0) for a in assets)
    total_likes = sum(a.get("likes_count", 0) for a in assets)
    
    return {
        "metrics": {
            "total_generated": total_generated,
            "hours_reclaimed": hours_saved,
            "community_impact": total_remixes,
            "total_likes": total_likes
        }
    }

@router.post("/submissions/{submission_id}/grade")
async def grade_submission(submission_id: str, user: dict = Depends(get_current_user)):
    """Triggers AI auto-grading for a student submission."""
    db = get_supabase_anon(user["token"])
    
    # 1. Fetch submission and asset details
    res = db.table("classroom_submissions").select("*, classroom_assignments(asset_id), profiles!student_id(full_name)").eq("id", submission_id).single().execute()
    if not res.data:
        raise HTTPException(status_code=404, detail="Submission not found")
    
    submission = res.data
    asset_res = db.table("teacher_assets").select("*").eq("id", submission["classroom_assignments"]["asset_id"]).single().execute()
    asset = asset_res.data
    
    # 2. Orchestrate grading via ClassroomExpert
    prompt = f"Grade this student submission.\nOriginal Quiz/Asset: {asset['content_json']}\nStudent Answers: {submission['answers_json']}\nStudent Name: {submission['profiles']['full_name']}"
    system_hint = "Return ONLY a JSON object: {'score': 0-100, 'feedback': 'Pedagogical feedback', 'status': 'graded'}"
    
    profile = {"user_role": "teacher", "subject": asset["subject"], "grade_level": asset["grade_level"]}
    reply = await get_orchestratorResponse(profile, prompt, system_hint=system_hint)
    
    try:
        clean_reply = reply.replace("```json", "").replace("```", "").strip()
        grading_json = __import__("json").loads(clean_reply)
        
        # 3. Update DB
        db.table("classroom_submissions").update({
            "grade_score": grading_json["score"],
            "feedback_text": grading_json["feedback"],
            "status": "graded",
            "graded_at": __import__("datetime").datetime.utcnow().isoformat()
        }).eq("id", submission_id).execute()
        
        return grading_json
    except Exception as e:
        return {"error": "Grading failed", "raw_reply": reply}

@router.post("/students/{student_id}/praise")
async def praise_student(student_id: str, req: dict, user: dict = Depends(get_current_user)):
    """Teacher sends a praise nudge to the student's linked parents."""
    db = get_supabase_anon(user["token"])
    
    # 1. Verify links (Parent/Student)
    links = db.table("parent_student_links").select("parent_id").eq("student_id", student_id).eq("status", "active").execute()
    if not links.data:
        return {"message": "No linked parents found to receive praise."}
    
    praise_msg = req.get("message", "Excellence in classroom activities!")
    teacher_name = user.get("full_name", "Your Teacher")
    
    # 2. Broadcast nudge to all linked parents
    nudges = []
    for link in links.data:
        nudge = {
            "parent_id": link["parent_id"],
            "student_id": student_id,
            "content": f"ğŸŒŸ Praise from {teacher_name}: {praise_msg}",
            "type": "praise",
            "is_active": True
        }
        # Assuming we have a parent_nudges or similar table for parent notifications
        # In current codebase, we have parent_nudges (parent -> student). 
        # Let's check if we have a table for parent-facing notifications.
        # Looking at parent.py, it seems parents see 'reports' or 'nudges'.
        # Let's create a teacher_praise table or reuse parent_nudges with a flag.
        # Actually, let's just insert into parent_nudges and the parent will see it on their portal.
        db.table("parent_nudges").insert(nudge).execute()
        nudges.append(nudge)
        
    return {"message": f"Praise sent to {len(nudges)} parents.", "success": True}
